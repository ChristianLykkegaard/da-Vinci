This chapter presents the design of a safe controller for the  robotic patient manipulator in 3D Cartesian space, where the unsafe region is defined as an ellipsoid with static boundaries, i.e. fixed in space with respect to time. The unsafe region is defined such that it is within the reach of the instrument tip. It is desired to construct the unsafe area such that the interior of the ellipsoid is unsafe, thus representing a heart or another vital sensitive organ which must not be cut under any circumstances. An important simplification is made throughout the entire chapter, i.e. the orientation of the hand is not considered.
\begin{figure}[H]
\centering
\subbottom[The Robotic patient manipulator.]{\includegraphics[width=0.45\textwidth]{rviz_09_17_18_frame1.pdf}\label{fig:rviz_09_17_18_frame}}%
	\hspace*{5mm}
\subbottom[The robot hand and instrument.]{\includegraphics[width=0.45\textwidth]{robot_hand_unsafe_region.pdf}\label{fig:robot_hand_unsafe_region}}%
\caption{Patient manipulator and a fixed region within the reachable space $\mathcal{X}$ that is unsafe, $\mathcal{X}_u$, marked by a red ellipsoid thus implying an ellipsoid as zero level set of the \gls{cbf}.}
\label{fig:robot_hand_3d}
\end{figure}
Given the reachability of the robotic end effector which is tested to be roughly a square with the measures [0.2 0.2 0.2]\,m centered in (0,0,0), the sets considered in this chapter can be outlined in \autoref{tab:intervals_3d}.
\begin{table}[H]
	\begin{tabularx}{\textwidth}{X X p{2.5cm} X}
\rowcolor{HeaderBlue} 
$\mathcal{X}$ & $\mathcal{X}_u$  & $\mathcal{X}_0$ & $\mathcal{T}$ \\
$\mathcal{X} = \{ x \in  [-\bar{\Lambda}_\text{lim}, \bar{\Lambda}_\text{lim}] $,\newline $ \phantom{\mathcal{X} = \{ } y \in [-\bar{\Lambda}_\text{lim}, \bar{\Lambda}_\text{lim}] $,\newline $\phantom{\mathcal{X} = \{ } z \in  [-\bar{\Lambda}_\text{lim}, \bar{\Lambda}_\text{lim}] \}$ & 
$\mathcal{X}_u$ consist of an ellipsoid with semi-axes $r_x,r_y,r_z$. &  $\mathcal{X}_u^c = \mathcal{X} \backslash \mathcal{X}_u $& $\mathcal{T}$ is a layer around the ellipsoid with $\text{thickness}=0.01\,$m.\\
\end{tabularx}
\caption{Sets considered in this chapter, where $r_x=0.03$\,m, $r_y=0.06$\,m, $r_z=0.03$\,m are lengths of the semi-axes of an ellipsoid and $\bar{\Lambda}_\text{lim}=0.1$m being the extremity of the box encircling the reachable space.}
\label{tab:intervals_3d}
\end{table}
%
The theory, analysis and implementation aspects presented in this chapter differ from the previous work in this report. In contrast to \autoref{chap:cbf_1d_static} and \autoref{chap:cbf_1d_dynamic}, which solely comprise the prismatic slide joint, this chapter concerns the five independent revolute joints as well (see \autoref{fig:naming_convention}). Accordingly, this chapter presents the material required to be able to manoeuvre the da Vinci robot in the 3D Cartesian space and to be able to specify an unsafe set $\mathcal{X}_u$ contained within an ellipsoid. This implies the topics:
\begin{itemize}
	\itemsep-0.7mm
\item Development of a sufficient model describing movement in three dimensions.
\item Construction of a control barrier function fulfilling the demand for an ellipsoid encirclement of $\mathcal{X}_u$.
\item Development of the control system.
\item Implementation in MATLAB.
\item Implementation on the da Vinci robot. This entails a kinematic description of the robot links and joints such that a translation between the 3D Cartesian space and the 6D joint space can be established.
\end{itemize}
Thus the first topic will be to model the movement sufficiently.
\section{Modelling of Robot Hand Movement in 3D}
The system shall be modelled as a linear state space system on the form:
\begin{flalign*}
\dot{\textbf{x}} &= \textbf{A}\,\textbf{x} + \textbf{B}\,\textbf{u} \\
\textbf{y} &= \textbf{C}\textbf{x}
\end{flalign*}
%In order to set up a dynamic model of the da Vinci robot hand, a decision is made to model the three axes as decoupled for initial simplification. \textcolor{red}{Argue why, something about measurement, as movements are composed from changing joint angles obviously the axes are coupled, but it is also dependent on the low level controllers on the FPGA.} Measurements are made for a step input on each of the three axes, as shown in \textcolor{red}{FIGURE}
The movement in the three dimensional space may be modelled as three decoupled systems. While there may be coupling between the systems, the decoupling simplifies the modelling phase significantly and it is still a realistic version of the real scenario.
%
%\textcolor{red}{Make measurement of step for cases: x-axis, y-axis, z-axis, and xyz at the same time. Compare to slide measurement.}
%
%It is decided to model the response for each of the three (decoupled) axes as three first order systems, and the open loop system for the robot hand is formulated as:
\begin{flalign}\label{eq:3D_sys_static_openloop}
\dot{\mathbf{x}}=
\dot{\begin{bmatrix}
x_x\\x_y\\x_z
\end{bmatrix}} =
\underbrace{\underbrace{\begin{bmatrix}
-1/\tau_x & 0 & 0\\0 & -1/\tau_y & 0 \\ 0 & 0 & -1/\tau_z
\end{bmatrix}}_{\textbf{A}}
\begin{bmatrix}
x_x\\x_y\\x_z
\end{bmatrix}}_{f(\mathbf{x})} +
\underbrace{\begin{bmatrix}
1/\tau_x& 0 & 0 \\ 0& 1/\tau_y & 0 \\0& 0& 1/\tau_z
\end{bmatrix}}_{g(\mathbf{x}) = \textbf{B}}
\mathbf{u}
\end{flalign}
\begin{tabular}{rp{12.5cm}} 
where  &  \\
$x_x$ & is the position in the $x$-axis \\
$x_y$ & is the position in the $x$-axis \\
$x_z$ & is the position in the $x$-axis \\
$\tau_x$ & is the time constant associated with a step purely in the $x$-axis \\
$\tau_y$ & is the time constant associated with a step purely in the $y$-axis \\
$\tau_z$ & is the time constant associated with a step purely in the $z$-axis 
\end{tabular}\\

The time constants are measured and as presented in \autoref{sec:step_3d} are found to be:
\begin{flalign*}
\tau_x = 0.070\,\text{s}, \qquad \tau_y = 0.100\,\text{s}, \qquad \tau_z = 0.040\,\text{s}
\end{flalign*}
With a sufficient model established the \gls{cbf} can be considered.
\section{Construction of CBF}
A \gls{cbf} is proposed that complies with the first two constraints in \autoref{def:barrier_certificate}, i.e. a function that is positive on the set $\mathcal{X}_u$ and nonpositive on the set $\mathcal{X}_0$. In order to make sure that the robot tool can be prevented from penetrating the heart or another desired three dimensional region, the unsafe set $\mathcal{X}_u$ is defined as an ellipsoid. This ellipsoid enclosing the region $\mathcal{X}_u$ as visualized in \autoref{fig:robot_hand_unsafe_region}, must be the zero level set of the CBF. The CBF is proposed of the form:
\begin{equation}
	B(\mathbf{x}) = -\left(  \left(\frac{x_x-c_x}{r_x}\right)^2 + \left(\frac{x_y-c_y}{r_y}\right)^2 + \left(\frac{x_z-c_z}{r_z}\right)^2 - 1 \right)\label{eq:barrier_3d}
\end{equation}
\begin{tabular}{rl}
	where&\\
	$[c_x\,\, c_y\,\, c_z]$ & is the coordinate of the center of the ellipsoid, $\mathbf{c}\in\mathbb{R}^3$ \\
	$[r_x\,\, r_y\,\, r_z]$ & is the lengths of the semi-axes of the ellipsoid, $\mathbf{r}\in\mathbb{R}^3_+$ \\
\end{tabular}\\

The \gls{cbf} is visualized in \autoref{fig:zerolevelset_3d}. The zero level set enclosing the unsafe region $\mathcal{X}_u$ shown as a green ellipsoid. Note that the function $-B(\mathbf{x})$ will have the same zero level set, but have positive values outside the ellipsoid, indicating that it is the safe area $\mathcal{X}_0$ that is enclosed by the ellipsoid.
\vspace{-0.5cm}
\begin{figure}[H]
\centering
	\hspace*{-3cm}
	\includegraphics[width=1.3\textwidth]{cbf_3d_init.eps}
	\caption{CBF on the form described in \autoref{eq:barrier_3d} with  $\mathbf{c}= [0,\,\,\,\, 0,\,\,\,\, 0]$ and $\mathbf{r}=[0.03,\,\,\,\, 0.05,\,\,\,\, 0.03]$.}
	\label{fig:zerolevelset_3d}
\end{figure}
%
%\begin{figure}[H]
%	\centering
%	\hspace*{-15mm}
%	\includegraphics[width=1.2\textwidth]{cbf_3d_init.eps}
%	\caption{Example of a CBF on the form described in \autoref{eq:barrier_3d}, here with $\mathbf{c}= [0.1,\,\,\,\, 0,\,\,\,\, -0.05]$ and $\mathbf{r}=[0.2,\,\,\,\, 0.1,\,\,\,\, 0.1]$. The zero level set is indicated by the red ellipsoid, while the black ellipsoid marks the one level set, indicating that the enclosed  region is the unsafe set $\mathcal{X}_u$).}
%	\label{fig:zerolevelset_3d}
%\end{figure}
%The third constraint in \autoref{def:barrier_certificate} is tested for a barrier certificate of this form with the system in \autoref{eq:3D_sys_static_openloop}. This is done by splitting the constraint up into the combined constraints on $L_gB(\mathbf{x})$ and $L_fB(\mathbf{x})$ from \autoref{req2}, first testing where $L_gB_0(\mathbf{x})=0$:
As suggested in \autoref{req2}, if $L_fB(\textbf{x})\neq 0\,\, \forall \, \textbf{x}$ then safety can always be guaranteed. Thus testing $L_fB(\textbf{x})$:
\begin{flalign}
	L_gB(\textbf{x}) = \frac{dB(\mathbf{x})}{d\mathbf{x}}g(\mathbf{x})\Bigm|_{g(\textbf{x})=\textbf{B}} &= \begin{bmatrix}
	 \dfrac{\partial B(\textbf{x})}{\partial x_x} & \dfrac{\partial B(\textbf{x})}{\partial x_y} & \dfrac{\partial B(\textbf{x})}{\partial x_z}
\end{bmatrix}\begin{bmatrix}
		1/\tau_x& 0 & 0 \\ 0& 1/\tau_y & 0 \\0& 0& 1/\tau_z
	\end{bmatrix}	\nonumber \\
	 &= 
	\begin{bmatrix} 
		\dfrac{2}{r_x^2}(c_x-x_x) & \dfrac{2}{r_y^2}(c_y-x_y) & \dfrac{2}{r_z^2}(c_z-x_z) 
	\end{bmatrix}
	\begin{bmatrix}
		1/\tau_x& 0 & 0 \\ 0& 1/\tau_y & 0 \\0& 0& 1/\tau_z
	\end{bmatrix} \nonumber\\
	&= 2
	\begin{bmatrix} 
		\dfrac{1}{r_x^2\tau_x}(c_x-x_x) & \dfrac{1}{r_y^2\tau_y}(c_y-x_y) & \dfrac{1}{r_z^2\tau_z}(c_z-x_z)  
	\end{bmatrix} \label{eq:LgB_3d} \\
	& \neq 0 \mm \forall \mm x_x \neq c_x, \mm x_y \neq c_y , \mm x_z \neq c_z  \nonumber
\end{flalign}
It can be seen that $L_gB(\mathbf{x})=0$ in the centre of the ellipsoid $[c_x,c_y,c_z]$, which is the vertex of the barrier function. While $L_gB(\textbf{x}) = 0$ implies the demand $L_fB(\textbf{x}) \leq 0$, it causes no issue in this specific case. Simply subtract a small region around the center of the ellipsoid, call it $\mathcal{S}=\{ x_x = [-\delta\,\,\,\,\,\, \delta], \,\, x_y = [-\delta\,\,\,\,\, \delta]\,\, x_z = [-\delta\,\,\,\,\, \delta] \}$ where $\delta$ is some small scalar, from $\mathcal{X}$ such that $\bar{\mathcal{X}} = \mathcal{X} \backslash \mathcal{S}$. Thus $B(\textbf{x})$ is valid on $\bar{\mathcal{X}}$. These considerations are valid as no trajectory under any circumstances will penetrate the surface of the ellipsoid, thus no reason to include the interior in $\mathcal{X}$. With $L_gB(\textbf{x}) \neq 0\,\, \forall \mathbf{x} \in \bar{\mathcal{X}}$, the control design can be initiated.
\section{Control Design}
The control design is built upon the control law from \autoref{eq:control_law}, i.e:
\begin{flalign}
u(\textbf{x},\tilde{\textbf{u}}) &= \sigma(\textbf{x})k_0(\textbf{x})+(1-\sigma(\textbf{x}))\tilde{u}(\textbf{x}) \label{eq:3d_main_contr} \\
&\text{with:} \nonumber \\
\tilde{u}(\textbf{x}) &= \bar{\textbf{N}}x_\text{ref} - \textbf{K}\textbf{x} \label{eq:normal_control_3d}
\end{flalign}
\begin{tabular}{rp{12.5cm}} 
where  &  \\
$u(\textbf{x},\tilde{u})$ & is the control input where safety ensured, $u(\textbf{x},\tilde{u})\in \mathbb{R}^3$ \\
$\tilde{u}(\textbf{x}) $ & is the input where no safety is considered, $\tilde{u}(\textbf{x})\in \mathbb{R}^3$\\
$k_0(\textbf{x})$ & is the controller ensuring safety, $k_0(\textbf{x})\in \mathbb{R}^3$ \\
$\sigma(\textbf{x})$ & founds a linear combination between the two control laws, $\sigma(\textbf{x})\in \mathbb{R}$ \\
$\bar{\textbf{N}}$ & ensures unity gain from reference input to output, $\bar{\textbf{N}}\in\mathbb{R}^{3\times 3}$ \\
$\textbf{K}$ & is the gain in the controller where no safety is considered, $\textbf{K}\in\mathbb{R}^{3\times 3}$ \\
$\textbf{x}$ & is the state vector, $\textbf{x}=[x_x \mm x_y \mm x_z]^T \in \mathbb{R}^3$
\end{tabular}\\

The input $\tilde{u}(\textbf{x})$ is used in the safe area and is found according to regular pole placement where stability is the main design consideration, thus the MATLAB command \texttt{acker} is simply used to places the poles faster than the system itself and in the left half plane in the complex frequency domain:
\begin{flalign}
\textbf{K} = \texttt{acker}\left(\textbf{A},\textbf{B},\begin{bmatrix}
-15 & -15 & -15
\end{bmatrix}\right) =  \begin{bmatrix}
0.050 & 0 & 0 \\
0 & 0.500 & 0 \\
0 & 0 & -0.385
\end{bmatrix}
\label{eq:k_3d}
\end{flalign}
The matrix $\bar{\textbf{N}}$ is found as \citep{bib:Nbar}:
\vspace*{-3mm}
\begin{flalign}
\bar{\mathbf{N}} = - \left( \mathbf{C}\,\mathbf{A}_{cl}^{-1}\,\mathbf{B} \right)^{-1} = \begin{bmatrix}
1.050 & 0 & 0 \\
0 & 1.500 & 0 \\
0 & 0 & 0.615
\end{bmatrix}
\label{eq:nbar_3d}
\end{flalign}

The safety controller $k_0(\textbf{x})$ requires both $L_gB(\textbf{x})$ and $L_fB(\textbf{x})$. With $L_gB(\textbf{x})$ found in \autoref{eq:LgB_3d}, $L_fB(\textbf{x})$ is found to:
%This means that instead of testing $L_fB(\mathbf{x})<0$ in this point, the relaxed requirement $L_fB(\mathbf{x})\leq 0$ applies:
\begin{flalign}
	L_fB(\mathbf{x}) &= \frac{d B(\mathbf{x})}{d \mathbf{x}}f(\mathbf{x})\Bigm|_{f(\textbf{x})= \textbf{A}\textbf{x}} = \begin{bmatrix}
	 \dfrac{\partial B(\textbf{x})}{\partial x_x} & \dfrac{\partial B(\textbf{x})}{\partial x_y} & \dfrac{\partial B(\textbf{x})}{\partial x_z}
\end{bmatrix} \textbf{A}\textbf{x} \nonumber \\ &= 
	\begin{bmatrix} 
		\dfrac{2}{r_x^2}(c_x-x_x) & \dfrac{2}{r_y^2}(c_y-x_y) & \dfrac{2}{r_z^2}(c_z-x_z) 
	\end{bmatrix}
	\begin{bmatrix}
		-1/\tau_x& 0 & 0 \\ 0& -1/\tau_y & 0 \\0& 0& -1/\tau_z
	\end{bmatrix} 
	\begin{bmatrix}
		x_x\\x_y\\x_z
	\end{bmatrix}\nonumber\\
	 &=
	-2\left(
	\frac{1}{r_x^2\tau_x}(c_xx_x-x_x^2) +\frac{1}{r_y^2\tau_y}(c_yx_y-x_y^2) + \frac{1}{r_z^2\tau_z}(c_zx_z-x_z^2) \right)
	\label{eq:Lf_3d}
%	\\	L_fB_0(c_x,c_y,c_z)&= 0 \nonumber
\end{flalign}
The control law presented in \autoref{eq:normal_control_3d} suggests a smooth transition on $\mathcal{T}$, just as derived in \autoref{chap:cbf_1d_static} and \autoref{chap:cbf_1d_dynamic}. This obeys with the desire to cover the ellipsoid with a 1\,cm thick rim (from \autoref{tab:intervals_3d}), such that the scalar $\epsilon > 0$ is introduced according to \autoref{eq:smoothness}, i.e.:
\begin{flalign}
\sigma(\textbf{x}) = 
\begin{cases}
0 & \text{if} \mm B(\textbf{x}) \leq -\epsilon \\
-2  \left( \dfrac{B(\textbf{x})}{\epsilon} \right)^3 - 3\left( \dfrac{B(\textbf{x})}{\epsilon} \right)^2 +1 \kk &\text{if} \mm B(\textbf{x}) \in (-\epsilon,0) \\
1  &\text{if} \mm B(\textbf{x}) \geq 0
\end{cases}
\label{eq:smoothness_3d}
\end{flalign} 
where $\epsilon$ can be found by considering the CBF:
\begin{flalign}
 \epsilon =	B(\mathbf{x})_{\left\vert \scriptsize \begin{matrix}
  \hspace{-0.8cm} x_z = 0 \\
 \hspace{0.1cm} x_x = r_x + 0.01 \\
 \hspace{-0.8cm} x_y = 0
\end{matrix}\right.} = -\left(  \left(\frac{r_x+0.01-c_x}{r_x}\right)^2 + \left(\frac{c_y}{r_y}\right)^2 + \left(\frac{c_z}{r_z}\right)^2 - 1 \right)_{\left\vert \scriptsize \begin{matrix}
\hspace{0.1cm} r_x  = 0.03 \\
\hspace{0.1cm} r_y = 0.06 \\
\hspace{0.1cm} r_z = 0.03 \\
\hspace{-0.3cm} c_x = 0 \\
\hspace{-0.3cm} c_y = 0 \\
\hspace{-0.3cm} c_z = 0
\end{matrix} \right.} = 0.778 
\label{eq:epsilon_3d}
\end{flalign}
Note that setting $x_x = r_x+0.01$ and  $x_y=x_z = 0$ ensures that a 1\,cm thick transition layer is designated around the ellipsoid. Thus, from \autoref{eq:control_law_safety}, the non-linear controller ensuring safety can be found as:
\begin{flalign}
k_0(\textbf{x}) = \begin{cases}
-\dfrac{L_fB(\textbf{x})+ \sqrt{(L_fB(\textbf{x}))^2 + \kappa^2L_gB(\textbf{x})(L_gB(\textbf{x}))^T}}{L_gB(\textbf{x})(L_gB(\textbf{x}))^T}(L_gB(\textbf{x}))^T &\text{if} \mm L_gB(\textbf{x}) \neq 0 \\
0  &\text{if} \mm L_gB(\textbf{x}) = 0
\end{cases}
\label{eq:ko_3d}
\end{flalign}
The control law can thereby be summarized.
\begin{recap}[Control Law for Safety Controller in the Euclidean Space]
Using \autoref{eq:3d_main_contr}, the control law can be summarized as:
\begin{flalign}
u(\mathbf{x},\tilde{u}) = \sigma(\mathbf{x})k_0(\mathbf{x}) + (1-\sigma(\mathbf{x}))\tilde{u}(\mathbf{x})
\end{flalign}
\begin{tabular}{rp{12.5cm}} 
where  &  \\
$\sigma(\mathbf{x})$ & is calculated in \autoref{eq:smoothness_3d} with $\epsilon$ from \autoref{eq:epsilon_3d} \\
$k_0(\textbf{x})$ & is calculated from \autoref{eq:ko_3d} with Lie derivatives from \ref{eq:LgB_3d} and \ref{eq:Lf_3d} \\
$\tilde{u}(\textbf{x})$ & is calculated from \autoref{eq:normal_control_3d} with $\bar{\textbf{N}}$ from \ref{eq:k_3d} and $\textbf{K}$ from \ref{eq:nbar_3d}
\end{tabular}\\
\end{recap}

\section{MATLAB Implementation}\label{sec:3d_matlab}
The MATLAB implementation can be found in found in \autoref{app:slide_implement_1} and in \autoref{app:cd} under the path \texttt{matlab\_scripts/safe\_3d/safety\_in\_3d.m}. The implementation is built upon these considerations:
\begin{itemize}
\item Forward Euler extrapolation.
\item Sampling time $f_s= 2\,$kHz.
\item Simulation time at 10\,s.
\item Various setpoints are given to illustrate how the controller ensures that the trajectory is redirected in alternative paths to ensure that the ellipsoid is not penetrated at any time.
\end{itemize}
The trajectory (blue) along with the immediate path (red) between  the given setpoints  (blue stars) and the unsafe set outlined by $B(\textbf{x})=0$ as an ellipsoid (green) are plotted in \autoref{fig:traj3d_1}. The black circle indicates the initial position (outside $\mathcal{X}_u$) of the trajectory and the destination coordinate is indicated as a green circle.
\begin{figure}[H]
\centering
	\hspace*{-2cm}
	\includegraphics[width=1.4\textwidth]{traj_3d_1.eps}
	\caption{Result of the MATLAB implementation of the safe controller which allows manoeuvring in the Euclidean space with an ellipsoid as zero level set of the CBF outlining $\mathcal{X}_u$. The trajectory (blue) along with the immediate trajectory (red) determined from the setpoints given (blue stars). The black circle indicates initial position and the green circle indicates the destination.}
	\label{fig:traj3d_1}
\end{figure}
It is from \autoref{fig:traj3d_1} seen how the controller ensures that the state  never enters the interior of the ellipsoid which indeed was the purpose of the controller. It is also seen how the controller ensures a smooth and elegant detour to reach the desired setpoint while ensuring safety. If a setpoint is given in the interior of $\mathcal{X}_u$, the state will settle at the shortest safe distance from that setpoint. It is finally seen how setpoints in the safe area are reached without any problems.

The state trajectory is also plotted in \autoref{fig:traj3d_2} where each coordinate trajectory is plotted individually which makes it slightly easier to see the effect of $\sigma(\textbf{x})$. 
\begin{figure}[H]
\centering
	\includegraphics[width=1\textwidth]{traj_3d_2.eps}
	\caption{The same trajectory as depicted in \autoref{fig:traj3d_1}. It is seen how  $\sigma(\textbf{x})$ increases in value when the trajectory approaches the zero level set of $B(\textbf{x})$ and the position is adjusted accordingly.}
	\label{fig:traj3d_2}
\end{figure}
It is from \autoref{fig:traj3d_2} seen how $\sigma(\textbf{x})$ increases in value when the trajectory approaches the zero level set of $B(\textbf{x})$, and the position is adjusted accordingly. Additionally,  \autoref{fig:traj3d_2} is the only plot where the actual dynamics can be seen, which clearly demonstrate the first order approximations in both $x,\,y$ and $z$. It is also seen how the dynamics is completely changed when the trajectory enters $\mathcal{T}$, hence causing a highly non-linear system, for which it actually is very difficult to predict the exact behaviour, except that it will escape the unsafe area.

The thickness of 1\,cm, outlining $\mathcal{T}$, ensured by $\epsilon$, is visualized in \autoref{fig:traj3d_2:med_sig} along with the simulated trajectory.
\begin{figure}[H]
\centering
	\includegraphics[width=1\textwidth]{traj_3d_med_sigma.jpg}
	\caption{The inner (black) ellipsoid marks the surface of $\mathcal{X}_u$ and the rim between the two ellipsoids is $\mathcal{T}$. Thus $\mathcal{X}_0 = \mathcal{X} \backslash \mathcal{X}_u$. The trajectory is initiated from the black circle.}
	\label{fig:traj3d_2:med_sig}
\end{figure}
It is from \autoref{fig:traj3d_2:med_sig} seen that the trajectory starts to be redirected when it enters $\mathcal{T}$ in a smooth manner. The trajectory will always take the shortest safe path.



%It is seen that $L_fB_0(\mathbf{x})$ complies with the relaxed constraint, and hence this candidate barrier function is validated and will be used in the design of the safety controller.

%\newpage
%Based on the modelled decoupled first order systems, identical linear position controllers as in \autoref{eq:utilde} are used for each axis, calculated as presented in \autoref{sec:K_Nbar_1D_1storder}, which results in the closed-loop system on the safe region $\mathcal{X}_0$ on the form
%\begin{equation}\label{eq:3D_sys_static}
%\small
%\dot{\begin{bmatrix}
%	x_x\\x_y\\x_z
%	\end{bmatrix}} =
%\underbrace{\begin{bmatrix}
%	-1/\tau_x & 0 & 0\\0 & -1/\tau_y & 0 \\ 0 & 0 & -1/\tau_z
%	\end{bmatrix}
%	\begin{bmatrix}
%	x_x\\x_y\\x_z
%	\end{bmatrix}}_{f(\mathbf{x})} +
%\underbrace{\begin{bmatrix}
%	1/\tau_x& 0 & 0 \\ 0& 1/\tau_y & 0 \\0& 0& 1/\tau_z
%	\end{bmatrix}}_{g(\mathbf{x})}
%\underbrace{\left(\begin{bmatrix}
%	\bar{\mathbf{N}}_x & 0 & 0 \\0 & \bar{\mathbf{N}}_y & 0 \\0& 0& \bar{\mathbf{N}}_z
%	\end{bmatrix}
%	\begin{bmatrix}
%	x_\text{ref}\\y_\text{ref}\\z_\text{ref}
%	\end{bmatrix}
%	-
%	\begin{bmatrix}
%	\mathbf{K}_x & 0 & 0 \\0 & \mathbf{K}_y & 0 \\0& 0&  \mathbf{K}_z
%	\end{bmatrix}
%	\begin{bmatrix}
%	x_x\\x_y\\x_z
%	\end{bmatrix}\right)}_{\tilde{\mathbf{u}}}
%\end{equation}
%\begin{tabular}{rl}
%where & \\
%$\tau$ & is the time constant given in \autoref{subsec:model_1d}, $\tau = 110$\,ms \textcolor{red}{NEW MEAS!}\\
%$\bar{\mathbf{N}}_i$ & are the system gains for each of the decoupled systems, computed according to \autoref{eq:barm_1}\\
%$\mathbf{K}_i$ & are the controller gains for each of the decoupled systems, computed according to \autoref{eq:K_1}\\
%\end{tabular}\\
%
%\textcolor{red}{pick  values for K and N }
%
%This position controller is used on the safe set $\mathcal{X}_0$, and when the state enters the transition area $\mathcal{T}$ (as defined in \autoref{eq:control_for_safety}) close to the set $\mathcal{X}_u$, the CBF should be used and the two controllers weighted with $\sigma$ as described in \autoref{eq:control_law}. The safe controller or CBF is designed in terms of a valid barrier certificate as defined in \autoref{eq:control_law_safety}, hence a candidate barrier certificate must be constructed.
%
%
%
%
%THIS IS ONLY POSITION, NOT ORIENTATION

%
%Hence, before modelling the system and designing a controller, the kinematics of the AAU da Vinci robot is presented in the following section along with considerations for the definition of the coordinate frames and the transformation between them constituting the kinematic description of the robot.
\section{Implementation on the da Vinci Robot}
In contrast to the MATLAB implementation, the implementation on the da Vinci robot comprises  some additional topics. The code developed as a result of the implementation can be found in \autoref{app:slide_implement_2}, \autoref{app:auxiliary} and \autoref{app:cd}. It can also be cloned from GitHub with the following git commands:
\begin{itemize}
\item \texttt{git clone https://github.com/AalborgUniversity-RoboticSurgeryGroup/Gr1032}
\item \texttt{git clone https://github.com/AalborgUniversity-RoboticSurgeryGroup/\newline davinci\_description ---branch reduced\_robot} 
\item \texttt{git clone https://github.com/AalborgUniversity-RoboticSurgeryGroup/\newline davinci\_driver ---branch gr1032}
\end{itemize}
It is also important to setup the ROS framework as described in \autoref{app:ros}. A complete description on how to run the developed framework is found in \autoref{appsec:ros_development}. The implementation of the controller derived in this chapter consists of the topics stated below:
\begin{itemize}
\item A description of the kinematic chain. This is required to compute the end effector position. The kinematic description is written in the ROS framework, located in the \texttt{davinci\_description} package under the folder \texttt{robots} as a number of \texttt{xacro} (XML macros) files. These \texttt{xacro} files are at launch time converted to a Unified Robot Description Format (URDF) such that kinematic solvers can access the information. The ROS framework and file system is described more thoroughly in \autoref{app:ros}.
\item Integration of an inverse kinematic solver such that a desired $(x,y,z)$ position can be obtained from the six active joint angles (see \autoref{fig:naming_convention}), i.e. from:
\begin{itemize}
\item \texttt{p4\_hand\_roll}
\item \texttt{p4\_hand\_pitch}
\item \texttt{p4\_instrument\_slide}
\item \texttt{p4\_instrument\_roll}
\item \texttt{p4\_instrument\_pitch}
\item \texttt{p4\_instrument\_jaw\_right}
\end{itemize}
\item Integration of a forward kinematic solver such that the position can be read from the six angles.
\item An original description of the kinematic chain is present at the Robotic Surgery Group - Aalborg University at GitHub. However, a modification of the kinematic chain is required such that only active joints are a part of the kinematic chain. This is necessary for the kinematic solver as it will not be able to distinct passive joints from active. 
\item Algorithm development such that the above topics are connected and real-time signal processing is ensured. As discussed in \autoref{sec:davinci-implementation}, this should be done in C++ in the ROS framework. 
\end{itemize} 
Thus before proceeding to the actual implementation, a kinematic description is necessary.

\subsection{Kinematics of the AAU da Vinci Robot}\label{britt}
The upcoming subsections will first describe how kinematics in general are defined, then how the kinematics are desired to be defined for the da Vinci robot followed by the original kinematic description (the structure of the \texttt{xacro} files when this project was initiated). It concludes with a necessary modification of the original kinematic description such that a sufficiently fast solver can be applied. 

\subsubsection{How a Kinematic Description is Defined}
A kinematic description of an object requires defining a right-handed coordinate frame fixed in the object and a coordinate frame fixed in inertial space, the latter which the position and orientation of the object can be described relative to. This relative orientation and position of an object (or the frame $i$ fixed in it) with respect to another frame $j=i-1$ can be described through a transformation matrix $\textbf{T}$, containing the orthonormal rotation matrix $\mathbf{R}$ and the translation vector $\textbf{p}$ of the frame origin, as 
\begin{equation}
^j_i\textbf{T} = 
\begin{bmatrix}
\mathbf{R} & \mathbf{p}\\
0 & 1
\end{bmatrix}, \label{eq:kin_transformation}
\qquad \text{where} \qquad
\textbf{p} = 
\begin{bmatrix}
a\\b\\d
\end{bmatrix}
\end{equation}
and the simplest rotation matrices $\mathbf{R}$ are rotations about a single axis, which can be combined to obtain an arbitrary rotation
\begin{small}
	\begin{equation}
	\textbf{R}_x(\alpha) = 
	\begin{bmatrix}
	1 & 0 & 0\\
	0 & \cos\alpha & -\sin\alpha\\
	0 & \sin\alpha & \cos\alpha
	\end{bmatrix} 
	\qquad
	\textbf{R}_y(\beta) = 
	\begin{bmatrix}
	\cos\beta & 0 & \sin\beta \\
	0 & 1 & 0\\
	-\sin\beta & 0 & \cos\beta
	\end{bmatrix}
	\qquad
	\textbf{R}_z(\theta) = 
	\begin{bmatrix}
	\cos\theta & -\sin\theta & 0\\
	\sin\theta & \cos\theta & 0\\
	0 & 0 & 1
	\end{bmatrix}
	\label{eq:RxRyRz_chapter}
	\end{equation}
\end{small}
\begin{tabular}{rp{12.5cm}} 
where  &  \\
$\alpha, \beta, \theta$ & are angles \\
$\textbf{R}_x(\alpha)$ & is rotation around the $x$-axis  \\
$\textbf{R}_y(\beta)$ & is rotation around the $y$-axis  \\
$\textbf{R}_z(\theta)$ & is rotation around the $z$-axis  
\end{tabular}\\

For the robotic patient manipulator, which comprises a number of links, coordinate frames are defined for each degree of freedom, i.e. placed in each joint such that one of the frame axes is the axis of free rotation or translation. The kinematic chain is now the sequence of alternate links and joints starting from the link fixed in inertial space and ending at the tip of the robotic tool. The link preceding a joint is its parent link, while the link succeeding it is its child link. The transformation between any two frames is given as the product of the transformation matrices in the kinematic chain between them. An example of a sequence of transformations can be seen in \autoref{app:kinematic_model_robot}.

\subsubsection{Desired Kinematic Description}
For the resolution of frame definitions it is preferred to adapt the  robot coordinate frame convention \gls{dh} because it is one of the most widespread kinematic descriptions in the robot kinematics community, and because it describes transformations between two successive frames in the kinematic chain on a succinct and standardized form, i.e.:
\begin{equation}
\hspace*{-2mm}
\small
^{i-1}_{\phantom{-1}i} \textbf{T} =
\begin{bmatrix}
\textbf{R}_z(\theta_i) & \begin{bmatrix}0\\ 0\\ d_i\end{bmatrix}\\
0 & 1
\end{bmatrix}
\begin{bmatrix}
\textbf{R}_x(\alpha_i) & \begin{bmatrix}a_i\\ 0\\ 0\end{bmatrix}\\
0 & 1
\end{bmatrix}
\label{eq:dh}
\end{equation}
In the \gls{dh} kinematic description each frame is fixed with respect to its parent link, and its $z$-axis is aligned with the actuation axis of its child link. The free rotation/translation always takes place around/along the local $z$ axis, and as seen from \autoref{eq:dh} any fixed or free rotation/translation about/along the $z$-axis is implemented (intrinsically) before any fixed rotation/translation about/along the (new) $x$-axis. For more details on the \gls{dh} convention and robot frames defined according to it, see \autoref{sec:denavit_hartenberg}.

%\begin{itemize}
%	\itemsep-1.3mm 
%	\item variable/parameter $\theta_i$ is the angle from $x_{i-1}$ to $x_i$ about $z_{i-1}$
%	\item variable/parameter $d_i$ is the distance from origin $i-1$ to $x_i$ measured along $z_{i-1}$
%	\item parameter $a_i$ is the distance from $z_{i-1}$ to $z_i$ measured along $x_i$
%	\item parameter $\alpha_i$ is the angle from $z_{i-1}$ to $z_i$ about $x_i$
%\end{itemize}
\subsubsection{Implementable Kinematic Description}
In the robot description in \gls{ros} (the implementation framework), however, the kinematics are described in the \texttt{xacro} files on the form
\begin{equation}
\hspace*{-2mm}
\small
^{i-1}_{\phantom{-1}i}\textbf{T} =
\begin{bmatrix}
\textbf{R}_z(\text{yaw})\textbf{R}_y(\text{pitch})\textbf{R}_x(\text{roll}) & \begin{bmatrix}a_i\\ b_i\\ d_i\end{bmatrix}\\
0 & 1
\end{bmatrix}
\begin{bmatrix}
\textbf{R}_z(\theta_i^*)\textbf{R}_y(\beta_i^*)\textbf{R}_x(\alpha_i^*) & \begin{bmatrix}a_i^*\\ b_i^*\\ d_i^* \end{bmatrix}\\
0 & 1
\end{bmatrix}
\label{eq:xacro_transformation_chapter}
\end{equation}
Here fixed translations are implemented first, then RPY rotations (extrinsic roll (about $x$-axis), pitch (about $y$-axis), yaw (about $z$-axis) rotation), and finally the free rotation or translation (denoted by $^*$ in \autoref{eq:xacro_transformation_chapter}) about/along one of the rotated axes. Furthermore, the convention here is that each frame (joint) is fixed in its child link (corresponding to the fixed rotations preceding the free rotation), and not in its parent link as in the DH convention. The transformation  $^{i-1}_{\phantom{-1}i} \textbf{T}$ is implemented in joint $i$ in the \texttt{xacro} file  as (for joint 8)
\begin{lstlisting}[language=xml]
<joint name="p4_hand_pitch"  type="revolute">
<origin
xyz="0 0 0"
rpy="1.5708 0 0" />
<parent link="rcm_vitual0" />
<child link="rcm_vitual1" />
<axis xyz="0 0 1" />
...
</joint>
\end{lstlisting}
Taking this small code example for the \texttt{p4\_hand\_pitch} joint, line 3 and 4 constitute the fixed translation and rotation of \autoref{eq:xacro_transformation_chapter}. Line 7 represents the latter part of \autoref{eq:xacro_transformation_chapter}, and combined with the information given from the \texttt{revolute} parameter, it suggests a free rotation about the $z$-axis (i.e. $\theta_i^*$) and that  $\textbf{R}_x(\alpha_i^*)  = \textbf{R}_y(\beta_i^*) = \mathbf{I}$ and $a_i^* = b_i^* = d_i^* = 0$ .

\subsubsection{Modifying the Kinematic Description to fit the Kinematic Solver}
The indisputable most important application of the kinematic description, is to use it for \gls{fk} and  \gls{ik}. The \gls{ik} is not a trivial task and can be implemented in different ways. Three candidate technologies are described in \autoref{tab:cand_ik}.
\begin{table}[H]
\begin{tabularx}{\textwidth}{X X X X}
\rowcolor{HeaderBlue} 
\textbf{Technology} &  \textbf{Advantage} &  \textbf{Disadvantage} & \textbf{Conclusion} \\
\textbf{MoveGroup} (a thorough test of MoveGroup is made in \autoref{sec:moveit}.) & This is an API which is easy and simple to use. It offers a GUI to initialize joints and links and certain poses. It is possible to specify joint limits. & It is slow and requires computational time between every setpoint. Also, it implements its own controller destructing the dynamics. & Due to the slow processing time and the shattered dynamics, the solver offered by the MoveGroup API is rejected. \\
\rowcolor{textBlue} 
\textbf{\gls{kdl}} (offered by The Orocos Project) (it is in fact the underlying solver of MoveGroup) & All additional features offered by MoveGroup can be bypassed and the speed can thereby be increased. & Interfacing with KDL directly complicates the code significantly. No specification of joint limits is possible. Cannot distinct between passive and active joints. & This is a good solution with the only real issue being the lack of joint limit specification. Passive joints can be omitted by redefining the kinematic description. \\
\textbf{Custom design} & Full control of all aspects of the solver and the possibility to tailor each developed feature. & The development of an IK solver for a six \gls{dof} manipulator is not a trivial task. & The extra features offered by a custom IK solver does not match the development costs which it will induce. \\
\end{tabularx}
	\caption{Candidate technologies to implement inverse kinematics and forward kinematics.}
\label{tab:cand_ik}
\end{table}
Weighting the advantages and disadvantages from \autoref{tab:cand_ik}, a proper solver is chosen as the KDL solver. Thus, the original kinematic description/chain needs to be modified to exclude all passive joints such that it only describes the active joints. This is necessary for the KDL solver as it otherwise will attempt to control passive joints. A simplified overview of the problem and how it is solved is outlined in \autoref{fig:simple_oveview_ik_solve}
%
\begin{figure}[H]
\centering
	\includegraphics[width=0.8\textwidth]{simple_kinematics.pdf}
	\caption{Modified kinematic chain. The two mimic joints (green) must be bypassed.}
	\label{fig:simple_oveview_ik_solve}
\end{figure}
%
The new modified set of frames is defined for the da Vinci kinematics, adhering to the \gls{dh} constraint  that all free rotation/translation is about/along the local $z$-axis. In conclusion the set of frames is modified to comply with the KDL solvers needs, i.e. a kinematic chain consisting of purely active joints.

%The distinction between the new modified kinematic description and the original frames are visualized in a simple manner in \autoref{fig:simple_oveview_ik_solve}. 
The new modified kinematic description is depicted more thoroughly in \autoref{fig:p4_hand_compromise_frames_chapter}. The parameters associated with these are listed in table \ref{tab:new_kin_short}. The original kinematic description, containing the two passive joints mimicking the hand pitch movement are depicted in \autoref{fig:p4_hand_xacro_frames_chapter} and the associated parameters are listed in table \ref{tab:old_kin_short} for comparison.  

\begin{table}[H]
	\small
	\centering
\subbottom[Original robot hand kinematics including mimicking joints, corresponding to \autoref{fig:p4_hand_xacro_frames_chapter}. The two mimicking joints mimic \texttt{hand\_pitch} are removed in the modified description.]{%
	\begin{tabular}{r | rrr | ccc | c l}\hline
		& \multicolumn{3}{c|}{fixed translation  [m]} & \multicolumn{3}{c|}{fixed rotation [rad]} & freedom & \\
		frame  & $a$ ($x$)  & $b$ ($y$)  & $d$ ($z$)  & roll  & pitch & yaw & $\alpha^*, \beta^*, \theta^*$ or $d^*$ & joint name\\\hline
		7 & -0.042 & 0 & 0.161 & 0 & 0 & 0 & $\phantom{-}\alpha_7^*$ & \texttt{hand\_roll} \\
		8 & 0 & 0 & 0 & 0 & -0.288 & 0 & $-\beta_8^*$ & \texttt{hand\_pitch} \\
		9 & 0.011 & 0 & 0.186 & $\pi$ & 0.288 & 0 & $\phantom{-}\beta_8$ & mimic \texttt{hand\_pitch} \\
		10 & 0.520 & 0 & 0 & $\pi$ & 0& 0 &  $-\beta_8$ & mimic \texttt{hand\_pitch} \\
		11 & 0 & 0 & -0.120  & 0 & 0 & 0 & $\phantom{-}d_{11}^*$ & \texttt{instrument\_slide} \\
		12 & 0.052 & 0 & 0 & $\pi$ & 0 & $\pi/2$ & $\phantom{-}\theta_{12}^*$ & \texttt{instrument\_roll} \\
		13 & 0 & 0 & 0.177 & 0 & 0 & 0 & $-\alpha_{13}^*$ & \texttt{instrument\_pitch} \\
		14L & 0 & 0 & 0.009 & $\pi/2$ & $\pi/2$ & 0 & $-\theta_{14L}^*$ & \texttt{instrument\_jaw\_left} \\
		14R & 0 & 0 & 0.009 & $\pi/2$ & $\pi/2$ & 0 & $\phantom{-}\theta_{14R}^*$ & \texttt{instrument\_jaw\_right} \\
	\end{tabular}\label{tab:old_kin_short}}
	\vspace*{1mm}
\subbottom[New modified robot hand kinematics excluding mimicking joints, corresponding to \autoref{fig:p4_hand_compromise_frames_chapter}.]{%
	\begin{tabular}{r | rrr | ccc | c l}\hline
		& \multicolumn{3}{c|}{fixed translation  [m]} & \multicolumn{3}{c|}{fixed rotation [rad]} & freedom & \\
		frame  & $a$ ($x$)  & $b$ ($y$)  & $d$ ($z$)  & roll  & pitch & yaw & $\theta^*$ or $d^*$ & joint name\\\hline
		7 & 0.482 & 0 & 0.047 & 0 & $\pi/2$ & 0 & $\theta_7^*$ & \texttt{hand\_roll} \\
		8 & 0 & 0 & 0 & $\pi/2$ & 0 & 0 & $\theta_8^*$ & \texttt{hand\_pitch} \\
		9 & 0.097 & 0 & 0 & 0 & $-\pi/2$ &  0 & $d_9^*$ & \texttt{instrument\_slide} \\
		10 & 0 & 0 & 0 & 0 & 0 & 0 & $\theta_{10}^*$ & \texttt{instrument\_roll} \\
		11 & 0 & 0 & 0 & 0 & $\pi/2$ & 0 & $\theta_{11}^*$ & \texttt{instrument\_pitch} \\
		12L & 0.009 & 0 & 0 & $-\pi/2$ & 0 & 0 & $\theta_{12L}^*$ & \texttt{instrument\_jaw\_left} \\
		12R & 0.009 & 0 & 0 & $-\pi/2$ & 0 & 0 & $\theta_{12R}^*$ & \texttt{instrument\_jaw\_right} \\
		\end{tabular}\label{tab:new_kin_short}}
	\caption{Parameters and variables (marked with $^*$) for the robot kinematic description implemented in \gls{ros} and visualized in \autoref{fig:robot_hand_kinematics}. Free angles are named with $\alpha$ for rotation about the $+x$-axis, $\beta$ about the $+y$-axis and $\theta$ about the $+z$-axis.}
	\label{tab:xacro_param_short}
\end{table}
The values are measured on the da Vinci robot in the AAU control and surgery laboratory. % It is in \autoref{tab:xacro_param_short} seen how the two mimic joints for \texttt{hand\_pitch} are excluded.
Note that the new set of frames does not adhere to the \gls{dh} standard completely, but they follow it as close as possible. The reason that the DH convention is not implemented fully is the underlying structure in the way the URDF file is read (in \autoref{eq:xacro_transformation_chapter} the free rotation/translation is post-multiplied the fixed rotation/translation, while in \autoref{eq:dh} the free rotation/translation is pre-multiplied). This is not straightforward to correct. The modified frames are tested and verified in \autoref{sec:app_activejoints_kinematics}.

At this point, all variables from \autoref{eq:xacro_transformation_chapter} are outlined in table \ref{tab:new_kin_short} and implemented in the corresponding \texttt{xacro} files in the \texttt{davinci\_description} package, i.e.:
\begin{itemize}
\item \texttt{robot/remote\_center\_manipulator.xacro} containing all joints associated with \texttt{p4\_hand}
\item \texttt{robot/instruments/needle\_driver.xacro} containing all joints associated with \texttt{p4\_instrument}
\end{itemize}
%
\begin{figure}[H]
\hspace*{-15mm}
\begin{minipage}{1.15\textwidth}
	\subbottom[Original robot hand kinematics including mimick joints, parameters given in table \ref{tab:old_kin_short}.]{\includegraphics[width=\textwidth]{p4_hand_xacro_frames_chapter.pdf}\label{fig:p4_hand_xacro_frames_chapter}}%
	\vspace*{5mm}
	\subbottom[New robot hand kinematics excluding mimick joints, parameters given in table \ref{tab:new_kin_short}.]{\includegraphics[width=\textwidth]{p4_hand_compromise_frames_chapter.pdf}\label{fig:p4_hand_compromise_frames_chapter}}%
	\caption{Orientation and position of coordinate frames 7,8, etc., corresponding to the controllable joints of the robotic patient manipulator.  For convenience of placing the hand roll and pitch frames in the pivot point (the stagnant fixed point) in the new kinematic description in \autoref{fig:p4_hand_compromise_frames_chapter}, a virtual link is inserted in the \texttt{xacro} file after each of these two joints.}
	\label{fig:robot_hand_kinematics}
\end{minipage}
\end{figure}
In conclusion a three dimensional position of the tool tip is described in a frame oriented as the inertial frame and offset such that a robot configuration with all free angles and slide set to zero equals a position of the tool tip in [0,0,0].

For more details on the original and new kinematic descriptions implemented in \gls{ros}; including all measurements of parameters, gearing ratios, code for testing the kinematic description in MATLAB, and measurements of distances for different configurations; please refer to \autoref{sec:existing_kinematics} and \ref{sec:app_activejoints_kinematics} in \autoref{app:kinematic_model_robot}.










\subsubsection{Employing Inverse Kinematics for a Controller in 3D Cartesian Space}
The controller relies on the use of inverse kinematics for the (ambiguous) mapping from 3D Cartesian space to 6D joint space. The inverse of the kinematic transformation matrix presented in \autoref{eq:kin_transformation} is \citep{bib:math_robotics}:
\begin{equation}
^j_i\textbf{T}^{-1} = 
\begin{bmatrix}
^j_i\textbf{R}^T & -^j_i\textbf{R}^T\,\,^j_i\textbf{p}\\
0 & 1
\end{bmatrix}
\end{equation}

With the sequence of transformations from frame $k$ to frame $i$ being represented by the transformation matrix $^k_i \textbf{T}$, the inverse transformation, from frame $i$ to frame $k$, is then its matrix inverse $^k_i \textbf{T}^{-1}$ \citep{bib:math_robotics}:
\begin{equation}
^k_i\textbf{T} = ^k_j\textbf{T} \,\, ^j_i\textbf{T} =
\begin{bmatrix}
^k_j\textbf{R} \,\, ^j_i\textbf{R} & ^k_j\textbf{p}+^k_j\textbf{R} \,\, ^j_i\textbf{p}\\
0 & 1
\end{bmatrix}
\qquad \Leftrightarrow \qquad
^k_i\textbf{T}^{-1} = 
\begin{bmatrix}
^j_i\textbf{R}^T\,\, ^k_j\textbf{R}^T & -\,^j_i\textbf{R}^T\,\, ^k_j\textbf{R}^T\,\,^k_j\textbf{p} -\, ^j_i\textbf{R}^T\,\, ^j_i\textbf{p}\\
0 & 1
\end{bmatrix}
\end{equation}

A mapping from six to three degrees of freedom is a surjective map, i.e. several elements in the 6D domain may map to the same element in the 3D co-domain. % The inverse map from 3D to 6D is accordingly injective and hence the mapping requires a decision of the "best" map. %
However the inverse map from 3D to 6D is neither injective nor surjective, as each element in the 3D domain can map to several elements in the 6D co-domain, and hence the mapping requires a decision of the "best" map.

In practice this mapping from the desired 3D Cartesian space configuration to a prudent 6D joint space position of the da Vinci robotic patient manipulator is handled by the \gls{kdl} inverse kinematics solver. Then the transformed joint position commands are published on the appropriate ROS topic and thereby passed to the low level controllers (see \autoref{fig:overview}).

The \gls{ik} \gls{kdl} solver employed in \gls{ros} utilizes the kinematic chain from the URDF, which is generated from the \texttt{xacro} link and joint kinematic description as presented in %\autoref{app:kinematic_model_robot}, the model implemented in ROS defined in
\autoref{sec:app_activejoints_kinematics}. From this chain % (\texttt{my\_chain} in the below example) 
a \gls{fk} position solver is created along with an \gls{ik} velocity solver in order to define the \gls{ik} position solver.

%\begin{lstlisting}[language=xml]
%//Create solver based on kinematic chain
%KDL::ChainFkSolverPos_recursive fksolver(my_chain);
%KDL::ChainIkSolverVel_pinv iksolverv(my_chain);
%KDL::ChainIkSolverPos_NR iksolver = KDL::ChainIkSolverPos_NR(my_chain,fksolver,iksolverv,100,1e-6);
%
%KDL::JntArray q(my_chain.getNrOfJoints());
%KDL::JntArray q_init(my_chain.getNrOfJoints());
%
%//Set destination frame
%double x, y, z;
%std::cout << "Set end-effector position <x y z>:" << std::endl;
%std::cin >> x >> y >> z;
%KDL::Vector dest_pos(x,y,z);
%KDL::Frame dest_frame(dest_pos);
%
%// Compute!
%int ret = iksolver.CartToJnt(q_init,dest_frame,q);
%\end{lstlisting}

The \gls{kdl} \gls{ik} position solver utilizes the Newton-Raphson (NR) iterative numerical technique through the function \texttt{CartToJnt} to determine a prudent joint configuration implementing the desired Cartesian configuration. Note that the NR requires both position and velocity (derivative of position) to find a solution.  %In the above example the initial guess \texttt{q\_init} of the joint configuration is the current joint configuration, and hence care should be taken to only command small changes in configuration for the sake of fast convergence of the \gls{ik} solution.

The actual implementation of the KDL solver follows the recommended implementation method as described by The Orocos Project main web page \citep{bib:kdl_stuff}.
Thus, the algorithm deployed for the KDL solver follows the steps described below:

\begin{figure}[H]
\centering
\begin{minipage}{0.48\textwidth}
\textbf{Utilize KDL for Forward Kinematics}
\begin{itemize}[leftmargin=*]
	\itemsep-0.5mm
\item Make a KDL tree (several chains) from URDF.
\item Fetch all KDL segments, i.e. links
\item Create chain from desired links: \texttt{p4\_rcm\_base} to \texttt{needle\_driver\_jawbone\_right}.
\item Create FK kinematic solver based on that chain
\item Get number of joints and create a joint array
\item Ask for joint values
\item Compute rotation/translation matrix $\mathbf{T}$
\end{itemize}
\end{minipage}
\hspace{0.3cm}
\begin{minipage}{0.48\textwidth}
%\vspace{0.3cm}
\textbf{Utilize KDL for Inverse Kinematics}
\begin{itemize}[leftmargin=*]
	\itemsep-0.5mm
%\item Make a KDL tree (several chains) from URDF.
%\item Fetch all KDL segments, i.e. links
%\item Create chain from desired links: \texttt{p4\_rcm\_base} to \texttt{needle\_driver\_jawbone\_right}.
\item First three points are identical to FK solver
%\item Create IK solver based in kinematic chain
\item Instantiate position solver $\mathbf{x}$ for Newton-Raphson (NR) based on that chain
\item Instantiate velocity solver $\dot{\mathbf{x}}$ for NR
\item Specify NR resolution and no. of iterations
\item Ask for desired $(x,y,z)$ destination
\item Call solver to compute necessary 6D angles 
\item Deliver result in a vector \texttt{q}
\end{itemize}
\end{minipage}
\end{figure}
The KDL solver is, however, far from perfect. At present time, the solver has a tendency to choose joint angles requiring multiple revolutions on the unit circle to obtain the same position as, obviously, less than one revolution could have done. This is caused by the lack of joint limit specification. The problem and the solution is outlined in \autoref{fig:correct_kdl} where \texttt{q(i)} is the $i^{\text{th}}$ controllable joint, e.g. \texttt{p4\_instrument\_roll}.
\begin{figure}[H]
\centering
	\includegraphics[width=0.65\textwidth]{unit_circle.pdf}
	\caption{Adjusting the KDL sultion for \texttt{q(i) > pi} and \texttt{q(i) < -pi} from red to blue direction of rotation.}
	\label{fig:correct_kdl}
\end{figure}
The solution found in \autoref{fig:correct_kdl} can be implemented as:
\begin{flalign*}
\text{while}(|q(i)|>\pi): \mm
q(i) = 
\begin{cases}
- \left( \pi - \left( q(i) - \pi \right) \right) \mm &\text{if} \mm q(i) > \pi  \\
 \left( \pi + \left( q(i) + \pi \right) \right) \mm &\text{if} \mm q(i) < -\pi  \\
q(i) \mm &\text{otherwise} 
\end{cases}
\end{flalign*}
This solution does, however, introduce limitations. The trajectory will inevitably be corrupted with flicker and other unsightly behaviours when the solver wishes to spin a joint multiple times around the unit circle. Additionally, not all joints can reach all the way to $\pm \pi$ which can cause imprecise settling stages. 

With the FK  and IK solver ready, the algorithm connecting the subtasks can be presented.

\subsection{Main Algorithm}
The main algorithm is outlined in \autoref{gif:3d_flow}.
\begin{figure}[H]
\centering
	\includegraphics[width=1\textwidth]{flowchart_3d_controller.pdf}
	\caption{Main algorithm for a safe controller in the 3 dimensional euclidean space.}
	\label{gif:3d_flow}
\end{figure}
The algorithm presented in \autoref{gif:3d_flow} comprises the entire code structure which will not be elaborated here, though as written in the introduction, it can be found in \autoref{app:slide_implement_2}. The real-time part runs every $0.01\,$s (100\,Hz) which corresponds to the publish rate which also is set to 100\,Hz. With all subtasks implemented appropriately, it is time to analyse the results.
\subsection{Results}
The results presented intends to demonstrate the below listed features:
\vspace{-3mm}
\begin{itemize}
	\itemsep-0.6mm
\item That the controller can find setpoints on $\mathcal{Y}=\mathcal{X}_0\setminus\mathcal{T}$.
\item That the controller is stable on $\mathcal{Y}$.
\item That the controller will redirect the trajectory to a safe area if the direct path to the setpoint passes through $\mathcal{X}_u$ or $\mathcal{T}$.
\item That the controller will ensure that the trajectory is redirected to a safe area if a setpoint is given on the unsafe set $\mathcal{X}_u$.
\item That $\sigma (\textbf{x})$ increases its value as the trajectory reaches $\mathcal{X}_u$ starting from $\mathcal{X}_0$ through $\mathcal{T}$ (from 0 to 1).
\end{itemize}

The execution time of the controller is validated first, and a measurement is plotted in \autoref{fig:3d_exe}. From this it is seen that the real time part is completed well within the 10\,ms (100\,Hz sample rate). As expected, the execution time is considerably higher than for the 1D system (compare to \autoref{fig:exe_1}) because of the necessity of an inverse kinematics solver.

\begin{figure}[h]
	\includegraphics[width=\textwidth]{exe_3d.pdf}
	\caption{Execution time for 3D system. It is seen that the controller never exceeds a computation time of 1.2\,ms. This plot can be reconstructed by running the MATLAB script \texttt{measurements/safety\_3d/execution\_time/plot\_exe\_3d.m} in \autoref{app:cd}.}
	\label{fig:3d_exe}
\end{figure}

The features listed above can be verified in the trajectory plot shown in \autoref{fig:3d_result}. Plot details and measurements  can be reconstructed by running the MATLAB script \texttt{plot\_3d\_meas.m} found in \autoref{app:cd} in the folder \texttt{measurements/safety\_3d}.
\begin{figure}[h]
\hspace{-45mm}
	\includegraphics[width=1.55\textwidth]{traj_3d_meas.eps}
	\caption{Results from safety controller in the 3D Euclidean space. The interior of the green ellipsoid comprises $\mathcal{X}_u$ and around it is a 1\,cm thick rim which constitutes $\mathcal{T}$ (not plotted). The trajectory is plotted with a blue color, and it is overlay with a green color if $\sigma(\textbf{x}) \in (0,0.25]$ and a magenta color if $\sigma(\textbf{x}) \in (0.25,1]$. The red lines demonstrate the direct path between two desired setpoints (red circles). The trajectory is initiated in $\mathbf{x}=(0.06,0.08,-0.01)$ (safe) and has a desired final destination in $\mathbf{x}=(0,0,0)$ (unsafe). This plot can be reconstructed by running the MATLAB script \texttt{measurements/safety\_3d/plot\_3d\_meas.m} in \autoref{app:cd}.}
	\label{fig:3d_result}
\end{figure}
The first 2-3 setpoints given in \autoref{fig:3d_result} are within the set $\mathcal{Y}$ and thereby safe. It is seen how the desired setpoints initially are reached (with a slight detour caused by the KDL solver). It is seen that when a setpoint is given which requires a path through $\mathcal{X}_u$, the safety controller gradually takes over and redirects the trajectory around $\mathcal{X}_u$ and finally allows it to find its reference value. 

It is also seen that $\sigma(\textbf{x})$ increases along with a shorter distance to $\mathcal{X}_u$, as indicated with green when $\sigma (\textbf{x}) \in (0,0.25]$ and magenta  when $\sigma (\textbf{x}) \in (0.25,1]$ in \autoref{fig:3d_result}. It can be noted that not all setpoints are reached completely, which is due to imprecise kinematics, joint values computed by the \gls{ik} solver that are outside the implementable range and last but not least, the lack of integral action in the controller. Finally, when a setpoint is given on $\mathcal{X}_u$, it is seen how the safety controller quite aggressively forces the trajectory away from $\mathcal{X}_u$. All these features are indeed the expected outcome of the controller, thus verifying the implementation. 

The result depicted in \autoref{fig:3d_result} and its associated analysis concludes the implementation.

\section{Conclusion for Safety in the 3D Euclidean Space}
\vspace{-3mm}	
A big step has been taken towards ensuring safety in the three dimensional Euclidean space, i.e. a three dimensional control barrier function which is defined to fulfil the demands given in \autoref{def:cbf} and a developed controller which proves itself very efficient in the MATLAB simulation environment, i.e. with ideal sampling rate and under no influence of an IK solver and other stochastic uncertainties. The controller fulfils all the initial outlined requirements.

The implemented controller on the da Vinci robot does indeed show the full potential of using barrier certificates in surgical robotics and proves that safety control can be implemented on a robot moving in 3D Cartesian space. It does, however, suffer from a poor IK solver, imprecise kinematics and the lack of integral action. Also, the model derived for the three dimensional space is very simplified, though sufficient to establish a "proof of concept" framework. 

An additional huge simplification is the consistent disregard of the orientation of the end effector in the implementation, thus merely guaranteeing safety for the position of the end effector, \underline{not} the full extent of the physical volume of the robotic tool. 

Due to present limitations in the TCP/IP connection to the robot the implementation is made at a 100\,Hz sampling rate, which causes erratic behaviour. Based on the results in \autoref{chap:cbf_1d_static} and \autoref{chap:cbf_1d_dynamic} it is expected that an increase of the sampling rate to  2\,kHz will smooth the behaviour of the trajectory on the verge of the transition region, where the safety controller starts to take effect. It is anticipated that the trajectory will settle at a near constant distance to the unsafe set on its path to setpoints "on the other side" of this region, similar to what was seen in the MATLAB simulation in \autoref{sec:3d_matlab}.

These topics are important to investigate and implement in future work.

