This appendix contains the MATLAB implementation of the slide controller developed in \autoref{chap:cbf_1d_static}. No user inputs are required to run the script. The script shown here includes no plotting, but the script found in \autoref{app:cd} under the path \texttt{matlab\_scripts/slide\_controller/slide\_controller.m} includes all plotting details.
\begin{lstlisting}[language=matlab]
model = 2; % 1 = first order model, 2 = second order model

%--- parabola coeficients for position constraints ---%
a = 16/9; b = 4/45; c = -2/225; 
%--- elliptic paraboloid  coeficients for position constraints ---%
x10 = 1/40; x20 = 0; a1 = -3/40; b1 = -10; c1 = 1; c2 = -1;

if model == 2
    s = tf('s'); % prepare Laplace operator
    ts = (28-9)*1/50; % 5 percent settling time
    tr = 0.1; % rise time
    wn = 1.8/tr; % calculate natural frequency
    zeta = -1/(wn*ts)*log(0.02); % calculate the damping ratio
    H = wn^2/(s^2 + 2*zeta*wn*s + wn^2); % calculate transfer function
    num = wn^2; % Specify numarator
    den = [1 2*zeta*wn wn^2]; % specify denominator
    A = [0 1; -wn^2 -2*zeta*wn];
    B = [0 wn^2]';
    C = [1 0];
    D = 0;
    sys = ss(A,B,C,D)
    x(1,1) = 0 % initial state position
    x(2,1) = 0; % initial state velocity
    K = acker(sys.a,sys.b,[-14 -15]);
elseif model == 1
    tau = 0.110; % time constant
    a_sys = -1/tau; %
    b_sys = 1/tau; % sine wave frequency
    sys = ss(a_sys,b_sys,1,0);
    x(1,1) = 0; % initial state;
    K = acker(a_sys,b_sys,[1.1*eig(sys.a)]); % control gain   
end

kappa = 1; % design parameter
Nbar = - inv(sys.c*inv(sys.a-sys.b*K)*sys.b); % ensure unity gain
scrsz = get(groot,'ScreenSize'); % get screen information

%--- Find epsilon ---%
x_epsilon = 0.04; % find epsilon from desired soft limit
epsilon = a*x_epsilon^2 + b*x_epsilon + c; % find epsilon
syms x0
softlims = solve(a*x0^2 + b*x0 + c == epsilon); % find soft limits
epsilon = abs(epsilon); % specify ep silon as a positive number

%--- make reference vector ---%
XREF = [0.02 0.09 -0.14 -0.02 0.045 0.01]; % simulation setpoints
xref = XREF(1); % initial reference

f = 100; Ts = 1/f; % sampling frequency
N = 5; % simulation time in seconds
fprintf('Simulation time: %d seconds\n', N)

i = (0:Ts:N); % make simulation resolution realistic
utilde = zeros(round(length(i)),1); % init utilde
Rplot(1) = 1; % init reference plot

for R = 1:length(i)
  %--- set various references ---%
  REFS = 6;
  if R == round(length(i)/REFS)*1
      xref = XREF(2);
      Rplot(2) = R;
  elseif R == round(length(i)/REFS)*2
      xref = XREF(3);
      Rplot(3) = R;
  elseif R == round(length(i)/REFS)*3
      xref = XREF(4);
      Rplot(4) = R;
  elseif R == round(length(i)/REFS)*4
      xref = XREF(5);
      Rplot(5) = R;
  elseif R == round(length(i)/REFS)*5
      xref = XREF(6);
      Rplot(6) = R;
  end
  
  %--- physical constraints for velocity  ---%
  if 1
    if model == 2
      max_vel = 1;
      if x(2,R) > max_vel
          x(2,R) = max_vel;
      elseif x(2,R) < -max_vel
          x(2,R) = -max_vel;
      end
    end
  end
 
  %--- output ---%
  y(:,R) = sys.C*x(:,R);
  
  %--- determine sigma  ---% 
  if model == 1
      if (a*(x(1,R))^2 + b*(x(1,R)) + c) <= -epsilon
          sigma = 0;
      elseif ((a*(x(1,R)).^2 + b*(x(1,R)) + c) > -epsilon) && ...
             ((a*(x(1,R)).^2 + b*(x(1,R)) + c) <  0)
          sigma = -2*((a*(x(1,R)).^2 + b*(x(1,R)) + c)/epsilon).^3 - ...
                   3.*((a*(x(1,R)).^2 + b*(x(1,R)) + c)/epsilon ).^2 + 1;
      else
          sigma = 1;
      end
  elseif model == 2
      cbf = (a.*(x(1,R)).^2 + b.*x(1,R) + c);
      if cbf <= -epsilon
          sigma = 0;
      elseif (cbf > -epsilon) && (cbf < 0)
          if model == 1
              sigma = -2*((a*(x(1,R)).^2 + b*(x(1,R)) + c)/epsilon).^3 - ...
                       3.*((a*(x(1,R)).^2 + b*(x(1,R)) + c)/epsilon ).^2 + 1;
          elseif model == 2
              sigma = -2*((a*(x(1,R)).^2 + b*(x(1,R)) + c)/epsilon).^3 - ...
                       3.*((a*(x(1,R)).^2 + b*(x(1,R)) + c)/epsilon ).^2 + 1;
          end
      else
          sigma = 1;
      end 
  end

  %--- print every thousand iteration to user ---%
  if mod(R,1000) == 1 
      if R ~= 1
          fprintf('iter = %d of %d\n', R-1, length(i)-1);
      else
          fprintf('iter = %d of %d\n', R, length(i)-1);
      end
  end

  %--- find lie derivatives ---%
  if model == 2
      LgB(1,R) = (c1*wn^2*(2*x(2,R) + 2*x20))/b1^2;
      LfB(1,R) = (c1*x(2,R)*(2*x(1,R) + 2*x10))/a1^2 - ...
          (c1*(2*x(2,R) + 2*x20)*(x(1,R)*wn^2 + 2*x(2,R)*zeta*wn))/b1^2; 
  elseif model == 1
      LgB(1,R) = (2*(a)*(x(:,R)) + (b))*(sys.b);
      LfB(1,R) = (2*(a)*(x(:,R)) + (b))*((sys.a)*x(:,R));
  end
  
  %-- Find controller by pole placement --%
  utilde(1,R) = xref*Nbar - K*x(:,R);

  %--- Find safe controller ---%
  threshold = 0.001;
  if abs(LgB(1,R)) >= threshold
      k0(1,R) = -( ( LfB(1,R) + sqrt(LfB(1,R)^2 ...
          + kappa^2*LgB(1,R)*LgB(1,R)' )) /  (LgB(1,R)*LgB(1,R)')  ) *LgB(1,R);
      kplot(1,R) =  k0(1,R);
  else
      k0(1,R) = 0;
      kplot(1,R) = k0(1,R);
  end 
  
  %--- control law ---%
  u0(1,R) = sigma*k0(1,R)+(1-sigma)*utilde(1,R);
  
  %--- physical constraints for control signal  ---%
  slide_lim = 0.1;
  if u0(1,R) > slide_lim
      u0(1,R) = slide_lim;
  elseif u0(1,R) < -slide_lim
      u0(1,R) = -slide_lim;
  end
 
  %--- save the LfclB ---%
  LfclB(1,R) = LfB(1,R) + LgB(1,R).*k0(1,R);
  
  %--- extrapolate with forward euler ---%
  xdot = sys.a*x(:,R) + u0(1,R)*sys.b;
  x(:,R+1) = xdot*Ts + x(:,R);
  sig(1,R) = sigma;
  
end
\end{lstlisting}