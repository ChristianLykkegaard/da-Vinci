
\section{Barrier Certificate Search for First Order 1D System}
A barrier certificate search is tested on the first order system as described in \autoref{subsec:model_1d}, i.e. for the  1D state space system with $x_1\in\mathcal{X}\subset\mathbb{R}$ corresponding to the robot slide joint being the only degree of freedom (see \autoref{fig:safe:overview} for an overview of the slide movement), with a linear position controller as described in \autoref{sec:K_Nbar_1D_1storder}, thus a closed-loop system
\begin{equation}
\dot{x} = \textbf{A}x+\textbf{B}u = \textbf{A}x+\textbf{B}(\bar{\mathbf{N}}x_\text{ref}-\textbf{K}x) = %-\tau^{-1}x+\tau^{-1}u=
-\tau^{-1}x+\tau^{-1}(\bar{\mathbf{N}}x_\text{ref}-\textbf{K}x), \kk \text{with }\tau=110\,\text{ms}\label{eq:sos_firstorder}
\end{equation}
This system is used in the following subsections in the barrier function search.

\subsection{First Order System with Zero Reference}
To give a clear picture of the structure of the \gls{sos} program, an initial exhaustive example is given for the simple 1D first order system with zero as reference position.
Define the open-loop system, and design a controller (with pole placement) as described in \autoref{sec:K_Nbar_1D_1storder}.
\begin{lstlisting}[language=matlab]
% Time constant from measurement
tau = 0.11;
% State-space matrices from first order open-loop system
A = -1/tau;
B = 1/tau;
% Setpoint controller that is xx times faster than the system
xx = 10;
K = place(A,B,[xx*A]);
\end{lstlisting}
Define the desired distance $\Delta$ between the safe and unsafe sets,  the minimum value $\bar{\epsilon}$ of the barrier function on the unsafe set, and the boundaries for each of the three sets $\mathcal{X}$, $\mathcal{X}_u$ and $\mathcal{X}_0$. %in order to get $\mathcal{X} =\{x\in[-0.1,0.1]\}$, $\mathcal{X}_u=\{x\in[0.05,0.1]\}$ and $\mathcal{X}_0=\{x\in[-0.1,0.05-\Delta]\}$.
\begin{lstlisting}[language=matlab]
% scaling factor = 1/100 for [meter], or 1 for [cm]
scale = 1/100;

% Distance between defined safe and unsafe regions
delta = 0.1*scale;

% Minimum value of the barrier certificate on the unsafe set Xu
epsilon = 0.001;

% Set upper and lower limits for the set intervals X, Xu and X0
Xmax = 10*scale;
Xmin = -10*scale;
Xumax = Xmax;
Xumin = 5*scale;
X0max = Xumin-delta;
X0min = Xmin;
\end{lstlisting}

Then the symbolic state variables are declared for the SOS program in SOSTOOLS with the command \texttt{pvar} (which corresponds to the command \texttt{syms} in the MATLAB symbolic toolbox). Now the SOS program \texttt{prog} can be initialized using the function \texttt{sosprogram} which takes the state variable(s) as input. 
\begin{lstlisting}[language=matlab]
% Declare state variables
pvar x1

% Initialize the sum of squares program
prog = sosprogram(x1);
\end{lstlisting}
%The reference for the robot position is generated as the 1D heart position, taking into account the system gain $\bar{N}$, and the closed-loop system equation is written as a function of the sybolic state. %\textcolor{red}{Something is wrong with the reference..?}
The vector field or derivative of the state can now be defined in terms on the symbolic state variable. This function is necessary for the SOS program when requiring that the Lie derivative of the barrier certificate must be negative on the set $\mathcal{X}$.
\begin{lstlisting}[language=matlab]
% Vector field dx/dt = fx (closed loop)
fx = (A-B*K)*x1;
\end{lstlisting}
For ease of defining a (1D) function $g$ that is positive on an interval [$p_1, p_2$], a parabola function is used.
\begin{lstlisting}[language=matlab]
function [a,b,c] = parabola(p1,p2,a)
	if ~exist('a','var')
		a=-1;
	end
	b=a*(p1^2-p2^2)/(p2-p1);
	c=-a*p1^2-b*p1;
end
\end{lstlisting}
Now declare the polynomial barrier function with the command \texttt{sospolyvar}. To do this, a monomial vector must be specified with \texttt{monomials} (see the monomial example in \autoref{eq:monomial_example}), which takes as input the state variable(s) and the monomial degree(s). The monomial degrees for $B(x)$ are chosen as low as possible until a solution can be found. In this case a solution can be found for a degree of $B(x)$ that is 0:4.
\begin{lstlisting}[language=matlab]
% Declare the polynomial barrier function
zB = monomials(x1,0:4);
[prog,Bar] = sospolyvar(prog,zB);
\end{lstlisting}
Now the region $\mathcal{X}$ can be defined for the slide region $\pm0.1$\,m using the Lie derivative inequality in \autoref{cer3_putinar}, which is defined with the command \texttt{sosineq}. The SOS polynomials $q$ are of the form in \autoref{eq:sos_polynomial}, i.e. $q=Z^TQZ$ (so the degree of $q$ is twice the degree of the monomial vector $Z$), and are declared with the command \texttt{sossosvar}, also taking a monomial vector as input.
\begin{lstlisting}[language=matlab]
% Define space X in Rn
[a,b,c] = parabola(Xmin,Xmax); % get coefficients for parabola which is positive for x in [-0.1,0.1] m
gX = a*x1^2+b*x1+c;

zX = monomials(x1,0:4);
[prog,qX] = sossosvar(prog,zX);

prog = sosineq(prog,-diff(Bar,x1)*fx-gX*qX);
\end{lstlisting}
Similarly, the region $\mathcal{X}_u$ is defined according to the SOS inequality in \autoref{cer2_putinar} as the area between slide positions 5-10\,cm.
\begin{lstlisting}[language=matlab]
% Define space Xu in X
[a,b,c]=parabola(Xumin,Xumax);
gXu = a*x1^2+b*x1+c;

zXu = monomials(x1,0:4);
[prog,qXu] = sossosvar(prog,zXu);

prog = sosineq(prog,Bar-epsilon-gXu*qXu);
\end{lstlisting}
And finally the region $\mathcal{X}_0$ is defined according to the SOS inequality in \autoref{cer1_putinar} as $\mathcal{X}_0\subset\mathcal{X}\setminus\mathcal{X}_u$, separated from the unsafe set by the distance $\Delta$.
\begin{lstlisting}[language=matlab]
% Define space X0 in X
[a,b,c]=parabola(X0min,X0max);
gX0 = a*x1^2+b*x1+c;

zX0 = monomials(x1,0:4);
[prog,qX0] = sossosvar(prog,zX0);

prog = sosineq(prog,-Bar-gX0*qX0);
\end{lstlisting}
With all three areas defined according to \autoref{eq:barrier_constraints_putinar}, the program is ready to be solved by using the command \texttt{sossolve}. If a solution is found, an overview of the solution accuracy is printed in the MATLAB terminal as the residual norm, number of iteration steps and solving time. To get the polynomial $B(x)$ use the function \texttt{sosgetsol}.
\begin{lstlisting}[language=matlab]
% Solve for barrier certificate
prog = sossolve(prog);
getB = sosgetsol(prog,Bar)
\end{lstlisting}

\vspace{-2mm}
From the terminal printout it is verified that the problem is neiter primal or dual infeasible, and that the feasibility ratio for this solution is given as 1.0122, which is fairly close to 1 and hence indicates that the solution is valid. The solution is found in 15 iterations with a residual norm of 7.5521e-10 and no indication of numerical errors.

To additionally verify that the solution is indeed valid, it is tested that the solution complies with the inequalities being \gls{sos} by testing if they can be resolved to the form in \autoref{eq:sos_polynomial}.
\begin{lstlisting}[language=matlab]
% Get coefficients for the remaining polynomials
getdBdx = diff(getB,x1)
getqXu1 = sosgetsol(prog,qXu);
getqX01 = sosgetsol(prog,qX0);
getqX1 = sosgetsol(prog,qX);

% Test if the inequalities are SOS
[Q,~,~] = findsos(getB-epsilon-gXu*getqXu1);
[Q2,~,~] = findsos(-getB-gX0*getqX01);
[Q3,~,~] = findsos(-diff(getB,x1)*fx-gX*getqX1);
\end{lstlisting}
%Result
%\begin{lstlisting}[language=matlab]
%Size: 188   33
%
%SeDuMi 1.3 by AdvOL, 2005-2008 and Jos F. Sturm, 1998-2003.
%Alg = 2: xz-corrector, Adaptive Step-Differentiation, theta = 0.250, beta = 0.500
%Put 5 free variables in a quadratic cone
%eqs m = 33, order n = 36, dim = 190, blocks = 8
%nnz(A) = 197 + 0, nnz(ADA) = 493, nnz(L) = 263
%it :     b*y       gap    delta  rate   t/tP*  t/tD*   feas cg cg  prec
%0 :            9.49E-01 0.000
%1 :   9.95E-04 1.03E-02 0.000 0.0109 0.9990 0.9990   1.00  1  1  5.3E-02
%2 :   1.92E-03 2.95E-03 0.000 0.2857 0.9000 0.9000   0.77  1  1  1.9E-02
%3 :   9.73E-03 7.23E-04 0.000 0.2453 0.9000 0.9000  -0.07  1  1  1.4E-02
%4 :   1.64E-01 6.45E-05 0.000 0.0892 0.9900 0.9900  -0.83  1  1  1.7E-02
%5 :   7.57E-01 1.66E-05 0.000 0.2580 0.9000 0.9000  -1.02  1  1  2.0E-02
%6 :   3.17E+00 4.40E-06 0.000 0.2641 0.9000 0.9000  -1.09  3  3  2.0E-02
%7 :   8.00E+00 1.35E-06 0.000 0.3071 0.9038 0.9000  -0.91  1  2  1.8E-02
%8 :   1.16E+01 3.80E-07 0.000 0.2815 0.9132 0.9000  -0.61  2  2  1.1E-02
%9 :   8.37E+00 8.48E-08 0.000 0.2232 0.9000 0.9067   0.05  2  2  3.9E-03
%10 :   4.64E+00 1.41E-08 0.000 0.1661 0.9056 0.9000   0.13  3  3  1.1E-03
%11 :   1.34E+00 2.89E-09 0.000 0.2049 0.9088 0.9000   0.77  4  3  2.6E-04
%12 :   7.91E-02 1.99E-10 0.436 0.0688 0.9900 0.9901   0.91  4  4  1.9E-05
%13 :   7.47E-03 1.24E-11 0.473 0.0624 0.9907 0.9900   0.94  4  4  1.3E-06
%14 :   2.91E-04 5.14E-13 0.486 0.0414 0.9900 0.9900   0.99  4  4  5.5E-08
%15 :   3.18E-06 1.10E-14 0.223 0.0215 0.9900 0.9905   1.01  5  5  1.1E-09
%
%iter seconds digits       c*x               b*y
%15      0.4   7.4  0.0000000000e+00  3.1754678011e-06
%|Ax-b| =   7.6e-10, [Ay-c]_+ =   2.3E-10, |x|=  1.7e+05, |y|=  8.0e+04
%
%Detailed timing (sec)
%Pre          IPM          Post
%6.200E-02    3.130E-01    2.300E-02    
%Max-norms: ||b||=1.000000e-03, ||c|| = 0,
%Cholesky |add|=1, |skip| = 0, ||L.L|| = 9.42104e+12.
%
%Residual norm: 7.5521e-10
%
%iter: 15
%feasratio: 1.0122
%pinf: 0
%dinf: 0
%numerr: 0
%timing: [0.0620 0.3130 0.0230]
%wallsec: 0.3980
%cpusec: 0.4531
%
%
%getB = 
%373.0249*x1^4 + 151.3339*x1^3 + 16.8843*x1^2 - 6.4509e-06*x1 - 0.061301
%
%
%getdBdx = 
%1492.0996*x1^3 + 454.0017*x1^2 + 33.7686*x1 - 6.4509e-06
%\end{lstlisting}

\vspace{-2mm}
This is indeed the case, and it is verified that a barrier certificate is found for the closed-loop system in \autoref{eq:sos_firstorder}, namely
\vspace{-2mm}
\begin{equation}
B(x_1) = 373.0249\cdot x_1^4 + 151.3339\cdot x_1^3 + 16.8843\cdot x_1^2 - 6.4509e\text{-}06\cdot x_1 - 0.061301
\end{equation}

\vspace{-3mm}
The first three coefficients of the polynomial barrier certificate are of ample size (not in the order 1e-5 or less), while the last seem unimportant. Decreasing the degree of the monomial $Z_B$ (and thereby the order of $B(x)$) to [2:4] does, however, not prove a proper solution, as the inequality \autoref{cer3_putinar} cannot be resolved on the form in \autoref{eq:sos_polynomial} and hence not \gls{sos}. The  barrier certificate is depicted in \autoref{fig:1D_1stordersys_noRef}.

\begin{figure}[htbp]
\centering%	\hspace*{-12mm}
\includegraphics[width=0.9\textwidth]{1D_1stordersys_noRef.pdf}
	\caption{A barrier certificate is found with SOSTOOLS that complies with the requirements in \autoref{eq:barrier_constraints}: it is positive ($B(x_1)\geq \bar{\epsilon}$) on $\mathcal{X}_u=\{x_1\in [0.05,0.1]\}$ and negative on $\mathcal{X}_0=\{x_1\in [-0.1,0.05-\Delta]\}$, and its Lie derivative is nonpositive on $\mathcal{X}=\{x_1\in [-0.1,0.1]\}$.}
	\label{fig:1D_1stordersys_noRef}
\end{figure}












\subsection{Verifying a Range of Reference Positions for the First Order System}


%The linear first order system from \autoref{eq:1storder_1D_ss} is defined with the same pole placement controller and thereby system gain as in \autoref{eq:K_1} and \ref{eq:barm_1}, and the same regions/intervals assigned for $\mathcal{X}$, $\mathcal{X}_u$ and $\mathcal{X}_0$ as given in \autoref{fig:safe:overview} - see \autoref{fig:intervals_for_sos}.
%\begin{lstlisting}[language=matlab]
%% 1D system WITH STATIC REFERENCE
%clear all; clc; 
%
%% Time constant from measurement
%tau = 0.11;
%% State-space matrices from first order open-loop system
%A = -1/tau;
%B = 1/tau;
%% Setpoint controller that is xx times faster than the system
%xx = 10;
%K = place(A,B,[xx*A]);
%
%C = 1;
%D = 0;
%Acl = A-B*K;
%sysol = ss(A,B,C,D);
%syscl = ss(Acl,B,C,D);
%
%% Internal gain in the system for compensation of the reference
%Nbar = -inv(C*inv(A-B*K)*B+D);
%
%% Set upper and lower limits for the set intervals X, Xu and X0
%Xmax = 0.1;
%Xmin = -0.1;
%Xumax = Xmax;
%Xumin = 0.05;
%X0max = Xumin;
%X0min = Xmin;
%\end{lstlisting}
%
%\begin{figure}[htbp]
%	\centering\includegraphics[width=0.6\textwidth]{intervals_for_sos.pdf}
%	\caption{Intervals for the 1D case study, where the solid black line represents the interval $\mathcal{X}=\{x_1\in [-0.1, 0.1]\}$, and the interval $\mathcal{X}_0$ defines the interval where $B(x)\leq 0$, while $\mathcal{X}_u$ defines the interval where $B(x)>0$, separated from the zero level set by the small distance $\epsilon$. The interval $\mathcal{X}_{0\Delta} \subset \mathcal{X}_0$ is the interval of positions from which a reference can be taken $x_{ref}\in\mathcal{X}_{0\Delta}$. This interval is slightly smaller than the safe initial set $\mathcal{X}_0$, separated from the zero level set of $B(x)$ by the small distance $\Delta$.}
%	\label{fig:intervals_for_sos}
%\end{figure}
%
%The small $\epsilon>0$ from \autoref{cer2_putinar} is defined "as small as possible", and another small $\Delta>0$ is introduced in order to be test for validity of a controller with references within the interval $\mathcal{X}_{0\Delta} \subset \mathcal{X}_0$ with a distance of at least $\Delta$ to the zero level set of $B(x)$, see \autoref{fig:intervals_for_sos}.
%\begin{lstlisting}[language=matlab]
%% Distance reference should keep to the unsafe region
%delta = 0.001;
%
%% Distance which the unsafe region is allowed to deviate from the desired zero level set specified by the g(x) defining Xu
%epsilon = 0.00001;
%\end{lstlisting}
%The SOS program is initialized with the augmented state $\tilde{x}$ and thereby vector field as defined in \autoref{eq:xtilde_1storder_1D}. 
%\begin{lstlisting}[language=matlab]
%% =============================================
%% Control Barrier Function Search for 1D system WITH STATIC REFERENCE
%pvar x1 xref
%xtilde = [x1; xref];
%
%% =============================================
%% First, initialize the sum of squares program
%prog = sosprogram(xtilde);
%
%% =============================================
%% Vector field dt/dx = fx (closed loop)
%fx = [A-B*K B*Nbar; 0 0]*xtilde;
%\end{lstlisting}
The polynomial $B(x)$ is declared in as small degree "as possible". If any odd-order functions $g_j$ exist, $B(x)$'s leading term should be of an even degree higher than the uneven degree of the leading term of that $g_jq_j$. \textcolor{red}{It is considered that $B(x)$ should only be a function of the position and not of the reference, as the controller is considered as a static position setpoint controller for one single reference, and the program then tests the set of controllers, each with a setpoint within the interval $\mathcal{X}_{0\Delta} \subset \mathcal{X}_0$, for safety.}
%\begin{lstlisting}[language=matlab]
%% =============================================
%% Declare polynomial degree of barrier function (FUNCTION OF BOTH X1 AND XREF?)
%zB = monomials(x1,0:4);
%[prog,Bar] = sospolyvar(prog,zB);
%\end{lstlisting}
As $B(x)$ should be valid for the set $\mathcal{X}$, $\mathcal{X}$ is defined by $g_1(x_1)$ being positive on the slide interval, \textcolor{red}{and simultaneously $g_2(x_{ref})$ being positive on the interval $\mathcal{X}_{0\Delta} \subset \mathcal{X}_0$.} See \autoref{fig:intervals_for_sos} and \ref{fig:1D_static_gfunctions}.

%\begin{figure}[htbp]
%	\hspace*{-5mm}
%	\subbottom[The $g(x_1)$ functions defining the sets $\mathcal{X}$, $\mathcal{X}_u$ and $\mathcal{X}_0$.]{\includegraphics[width=0.55\textwidth]{1stordersys_staticlimits_g.pdf}\label{fig:1stordersys_staticlimits_g}}%
%	\hspace{-2mm}
%	\subbottom[The function $g(x_{ref})$ also used to define $\mathcal{X}$.]{\includegraphics[width=0.55\textwidth]{1stordersys_staticlimits_gref.pdf}\label{fig:1stordersys_staticlimits_gref}}%
%	\caption{The functions $g$ used to define the sets $\mathcal{X}$, $\mathcal{X}_u$ and $\mathcal{X}_0$ by the interval in which they are positive, i.e. $\mathcal{X}_u$ is defined by the interval where $g_{X_u}(x_1)$ is positive in \autoref{fig:1stordersys_staticlimits_g}. In the definition of the set $\mathcal{X}$, corresponding to the space where the barrier certificate is valid, also a function $g$ of the reference/setpoint is used. This means that the barrier certificate is valid for all controllers with setpoint within the interval where $g(x_{ref})$ is positive.}
%	\label{fig:1D_static_gfunctions}
%\end{figure}

%\begin{lstlisting}[language=matlab]
%% =============================================
%% Define space X in Rn
%
%% Define g1(x1) to be positive on the region that we want X to encompass
%[a,b,c]=parabola(Xmin,Xmax); % get coefficients for parabola
%gX1 = a*x1^2+b*x1+c;
%
%% Declare SOS polynomials q1(xtilde) in the full state (CHOICE OF DEGREEE?)
%zX1 = monomials(xtilde,0:2); 
%[prog,qX1] = sossosvar(prog,zX1);
%
%% With g2(xref) define X only on the interval of allowed references
%[a,b,c]=parabola(X0min+delta,X0max-delta);
%gX2 = a*xref^2+b*xref+c;
%
%% Declare SOS polynomials q2(xtilde) (CHOICE OF DEGREE?)
%zX2 = monomials(xtilde,0:2);
%[prog,qX2] = sossosvar(prog,zX2);
%
%% Setup SOS inequality according to Putinar's Positivstellensatz
%prog = sosineq(prog,-[diff(Bar,x1) diff(Bar,xref)]*fx-gX1*qX1-gX2*qX2);
%\end{lstlisting}
The unsafe set is defined as the interval where the position $x_1$ takes values between 5 and 10\,cm, see \autoref{fig:intervals_for_sos} and \ref{fig:1D_static_gfunctions}. \textcolor{red}{It is not clear whether also the reference should be part of the definition of $\mathcal{X}_u$ (with a $g_2(x_{ref})$ positive on the same interval as $g_1(x_1)$), it has been tested both with and without, but there is no clear indication from the results that is should or should not be included.}
%\begin{lstlisting}[language=matlab]
%% =============================================
%% Define space Xu in X
%
%% Define g1(x1) to be positive on the region that we want Xu to encompass
%[a,b,c]=parabola(Xumin,Xumax);
%gXu1 = a*x1^2+b*x1+c;
%
%% Declare SOS polynomials q1(xtilde) in the full state (CHOICE OF DEGREEE?)
%zXu1 = monomials(xtilde,0:3);
%[prog,qXu1] = sossosvar(prog,zXu1);
%
%% With g2(xref) define Xu outside the interval of allowed references
%[a,b,c]=parabola(Xumin,Xumax);
%gXu2 = a*xref^2+b*xref+c;
%
%% Declare SOS polynomials q2(xtilde) (CHOICE OF DEGREE?)
%zXu2 = monomials(xtilde,0:3);
%[prog,qXu2] = sossosvar(prog,zXu2);
%
%% Setup SOS inequality according to Putinar's Positivstellensatz
%prog = sosineq(prog,Bar-epsilon-gXu1*qXu1);%-gXu2*qXu2);
%\end{lstlisting}
\textcolor{red}{The same is the case for the definition of $\mathcal{X}_0$; it is defined as the safe position region, and it has been tested with and without the requirement of references in the interval $\mathcal{X}_{0\Delta} \subset \mathcal{X}_0$.}
%\begin{lstlisting}[language=matlab]
%% =============================================
%% Define space X0 in X
%
%% Define g1(x1) to be positive on the region that we want X0 to encompass
%[a,b,c]=parabola(X0min,X0max);
%gX01 = a*x1^2+b*x1+c;
%
%% Declare SOS polynomials q1(xtilde) in the full state (CHOICE OF DEGREEE?)
%zX01 = monomials(xtilde,0:4);
%[prog,qX01] = sossosvar(prog,zX01);
%
%% With g2(xref) define X0 only on the interval of allowed references
%[a,b,c]=parabola(X0min+delta,X0max-delta);
%gX02 = a*xref^2+b*xref+c;
%
%% Declare SOS polynomials q2(xtilde) (CHOICE OF DEGREE?)
%zX02 = monomials(xtilde,0:3);
%[prog,qX02] = sossosvar(prog,zX02);
%
%% Setup SOS inequality according to Putinar's Positivstellensatz
%prog = sosineq(prog,-Bar-gX01*qX01);%-gX02*qX02);
%\end{lstlisting}
In most cases the solution found has a leading term coefficient of order between -4 and -2, but very often the value of $B(x)$ is either positive or negative on the entire interval [-0.1,0.1]. \textcolor{red}{Strangely, in all tested combinations, $L_{f_{cl}}B(x)$ is positive-valued on an interval approximately [-0.02,0]. This and the fact that the zero level set of the barrier in no case is in $x=0.05$ makes it seem like we still haven't formulated the problem correctly in terms of the SOS description. We could use a little help to see what we do wrong.} 
%\begin{lstlisting}[language=matlab]
%% =============================================
%% Solve for B
%prog = sossolve(prog);
%getB = sosgetsol(prog,Bar)
%
%dBdx = [diff(getB,x1) diff(getB,xref)]
%
%% =============================================
%% Plot B and LfclB
%figure
%subplot(1,2,1);
%Bx = plotB(getB,[Xmin,Xmax],0);
%subplot(1,2,2);
%LfclB = plotLfclB(dBdx,A,B,C,D,K,Nbar,[Xmin,Xmax]);
%\end{lstlisting}

\textcolor{red}{It has been tried tweaking the constants $\epsilon$ and $\Delta$ as well as testing with all the monomial degrees $Z_B$, $Z_{X1}$, $Z_{X2}$, $Z_{u1}$, ($Z_{u2}$), $Z_{01}$, ($Z_{02}$), in degrees 0:2, 0:3, 0:4, and in/excluding the constraints from $x_{ref}$ on $\mathcal{X}_u$ an $\mathcal{X}_0$, but in no case $B(x)$ attains a shape that remotely reflects the requirements (on $x_1$) for $\mathcal{X}_u$ an $\mathcal{X}_0$.}


or decreasing the region $\mathcal{X}_0$